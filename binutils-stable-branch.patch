diff --git a/bfd/ChangeLog b/bfd/ChangeLog
index 9fac12538a..2bca0948f6 100644
--- a/bfd/ChangeLog
+++ b/bfd/ChangeLog
@@ -1,3 +1,82 @@
+2020-10-09  Alan Modra  <amodra@gmail.com>
+
+	* elf64-ppc.c (write_plt_relocs_for_local_syms): Don't do local
+	entry offset optimisation.
+
+2020-10-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/26711
+	* elfxx-x86.c (_bfd_x86_elf_merge_gnu_properties): Merge -z ibt
+	and -z shstk only with GNU_PROPERTY_X86_FEATURE_1_AND.
+
+2020-09-28  Alan Modra  <amodra@gmail.com>
+
+	PR 26656
+	* elf64-ppc.c (ppc_build_one_stub, ppc_size_one_stub): Check for
+	NULL stub_entry->h before calling is_tls_get_addr.
+
+2020-09-26  Alan Modra  <amodra@gmail.com>
+
+	* elf64-ppc.c (GLINK_PLTRESOLVE_SIZE): Depend on has_plt_localentry0.
+	(LD_R0_0R11, ADD_R11_R0_R11): Define.
+	(ppc64_elf_tls_setup): Disable params->plt_localentry0 when power10
+	code detected.
+	(ppc64_elf_size_stubs): Update __glink_PLTresolve eh_frame.
+	(ppc64_elf_build_stubs): Move r2 save to start of __glink_PLTresolve,
+	and only emit for has_plt_localentry0.  Don't use r2 in the stub.
+
+2020-09-24  Nick Clifton  <nickc@redhat.com>
+
+	Import from mainline:
+	2020-08-29  Nick Clifton  <nickc@redhat.com>
+
+	PR 26520
+	* dwarf2.c (scan_unit_for_symbols): Add member entries to the
+	variable table.
+
+2020-09-24  Alan Modra  <amodra@gmail.com>
+
+	PR 26656
+	* elf64-ppc.c (plt_stub_size): Add "odd" param.  Use it with
+	size_power10_offset rather than calculating from start of stub.
+	Add size for notoc tls_get_addr_opt stub.
+	(plt_stub_pad): Add "odd" param, pass to plt_stub_size.
+	(build_tls_get_addr_head, build_tls_get_addr_tail): New functions.
+	(build_tls_get_addr_stub): Delete.
+	(ppc_build_one_stub): Use a temp for htab->params->stub_bfd.
+	Emit notoc tls_get_addr_opt stub.  Move eh_frame code to
+	suit.  Adjust code to use bfd_tls_get_addr_head/tail in place
+	of build_tls_get_addr_stub.
+	(ppc_size_one_stub): Size notoc tls_get_addr_opt stub.
+	Adjust plt_stub_size and plt_stub_pad calls.  Correct "odd"
+	when padding stub.  Size eh_frame for notoc stub too.
+	Correct lr_restore value.
+	(ppc64_elf_relocate_section): Don't skip over first insn of
+	notoc tls_get_addr_opt stub.
+
+2020-09-24  Alan Modra  <amodra@gmail.com>
+
+	PR 26655
+	* elf64-ppc.c (ppc64_elf_func_desc_adjust): Rename to..
+	(ppc64_elf_edit): Call params->edit.
+	(ppc64_elf_tls_setup): Don't call _bfd_elf_tls_setup.  Return a
+	bfd_boolean.
+	* elf64-ppc.h (struct ppc64_elf_params): Add "edit".
+	(ppc64_elf_tls_setup): Update declaration.
+
+2020-09-24  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2020-08-13  Alan Modra  <amodra@gmail.com>
+	* elf64-ppc.h (struct ppc64_elf_params): Add no_pcrel_opt.
+	* elf64-ppc.c (ppc64_elf_relocate_section): Disable GOT reloc
+	optimizations when --no-toc-optimize.  Disable R_PPC64_PCREL_OPT
+	optimization when --no-pcrel-optimize.
+
+2020-09-19  Nick Clifton  <nickc@redhat.com>
+
+	* development.sh (development): Set to true.
+
 2020-09-19  Nick Clifton  <nickc@redhat.com>
 
 	This is the 2.35.1 point release.
diff --git a/bfd/development.sh b/bfd/development.sh
index 32be4b9460..6bbed41d6d 100644
--- a/bfd/development.sh
+++ b/bfd/development.sh
@@ -16,7 +16,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 # Controls whether to enable development-mode features by default.
-development=false
+development=true
 
 # Indicate whether this is a release branch.
 experimental=false
diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
index b8f0008a10..977bf43a6a 100644
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -3404,7 +3404,8 @@ scan_unit_for_symbols (struct comp_unit *unit)
       else
 	{
 	  func = NULL;
-	  if (abbrev->tag == DW_TAG_variable)
+	  if (abbrev->tag == DW_TAG_variable
+	      || abbrev->tag == DW_TAG_member)
 	    {
 	      size_t amt = sizeof (struct varinfo);
 	      var = (struct varinfo *) bfd_zalloc (abfd, amt);
@@ -3516,7 +3517,7 @@ scan_unit_for_symbols (struct comp_unit *unit)
 		      spec_var = lookup_var_by_offset (attr.u.val,
 						       unit->variable_table);
 		      if (spec_var == NULL)
-			{	
+			{
 			  _bfd_error_handler (_("DWARF error: could not find "
 						"variable specification "
 						"at offset %lx"),
diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
index 4bf37e1d98..ec8c85eba5 100644
--- a/bfd/elf64-ppc.c
+++ b/bfd/elf64-ppc.c
@@ -114,7 +114,7 @@ static bfd_vma opd_entry_value
 #define elf_backend_adjust_dynamic_symbol     ppc64_elf_adjust_dynamic_symbol
 #define elf_backend_hide_symbol		      ppc64_elf_hide_symbol
 #define elf_backend_maybe_function_sym	      ppc64_elf_maybe_function_sym
-#define elf_backend_always_size_sections      ppc64_elf_func_desc_adjust
+#define elf_backend_always_size_sections      ppc64_elf_edit
 #define elf_backend_size_dynamic_sections     ppc64_elf_size_dynamic_sections
 #define elf_backend_hash_symbol		      ppc64_elf_hash_symbol
 #define elf_backend_init_index_section	      _bfd_elf_init_2_index_sections
@@ -211,9 +211,10 @@ static bfd_vma opd_entry_value
 #define PLD_R12_PC	0x04100000e5800000ULL
 #define PNOP		0x0700000000000000ULL
 
-/* __glink_PLTresolve stub instructions.  We enter with the index in R0.  */
+/* __glink_PLTresolve stub instructions.  We enter with the index in
+   R0 for ELFv1, and the address of a glink branch in R12 for ELFv2.  */
 #define GLINK_PLTRESOLVE_SIZE(htab)			\
-  (8u + (htab->opd_abi ? 11 * 4 : 14 * 4))
+  (8u + (htab->opd_abi ? 11 * 4 : htab->has_plt_localentry0 ? 14 * 4 : 13 * 4))
 					/* 0:				*/
 					/*  .quad plt0-1f		*/
 					/* __glink:			*/
@@ -229,11 +230,14 @@ static bfd_vma opd_entry_value
 					/*  mtctr %12			*/
 					/*  ld %11,16(%11)		*/
 					/*  bctr			*/
-#define MFLR_R0		0x7c0802a6	/*  mflr %r0			*/
-#define MTLR_R0		0x7c0803a6	/*  mtlr %r0			*/
-#define SUB_R12_R12_R11	0x7d8b6050	/*  subf %r12,%r11,%r12		*/
-#define ADDI_R0_R12	0x380c0000	/*  addi %r0,%r12,0		*/
-#define SRDI_R0_R0_2	0x7800f082	/*  rldicl %r0,%r0,62,2		*/
+
+#define MFLR_R0		0x7c0802a6	/* mflr %r0			*/
+#define MTLR_R0		0x7c0803a6	/* mtlr %r0			*/
+#define SUB_R12_R12_R11	0x7d8b6050	/* subf %r12,%r11,%r12		*/
+#define ADDI_R0_R12	0x380c0000	/* addi %r0,%r12,0		*/
+#define SRDI_R0_R0_2	0x7800f082	/* rldicl %r0,%r0,62,2		*/
+#define LD_R0_0R11	0xe80b0000	/* ld %r0,0(%r11)		*/
+#define ADD_R11_R0_R11	0x7d605a14	/* add %r11,%r0,%r11		*/
 
 /* Pad with this.  */
 #define NOP		0x60000000
@@ -6340,13 +6344,13 @@ static const struct sfpr_def_parms save_res_funcs[] =
   };
 
 /* Called near the start of bfd_elf_size_dynamic_sections.  We use
-   this hook to a) provide some gcc support functions, and b) transfer
-   dynamic linking information gathered so far on function code symbol
-   entries, to their corresponding function descriptor symbol entries.  */
+   this hook to a) run the edit functions in this file, b) provide
+   some gcc support functions, and c) transfer dynamic linking
+   information gathered so far on function code symbol entries, to
+   their corresponding function descriptor symbol entries.  */
 
 static bfd_boolean
-ppc64_elf_func_desc_adjust (bfd *obfd ATTRIBUTE_UNUSED,
-			    struct bfd_link_info *info)
+ppc64_elf_edit (bfd *obfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
 {
   struct ppc_link_hash_table *htab;
 
@@ -6354,6 +6358,9 @@ ppc64_elf_func_desc_adjust (bfd *obfd ATTRIBUTE_UNUSED,
   if (htab == NULL)
     return FALSE;
 
+  /* Call back into the linker, which then runs the edit functions.  */
+  htab->params->edit ();
+
   /* Provide any missing _save* and _rest* functions.  */
   if (htab->sfpr != NULL)
     {
@@ -7694,9 +7701,11 @@ ppc64_elf_inline_plt (struct bfd_link_info *info)
   return TRUE;
 }
 
-/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
+/* Set htab->tls_get_addr and various other info specific to TLS.
+   This needs to run before dynamic symbols are processed in
+   bfd_elf_size_dynamic_sections.  */
 
-asection *
+bfd_boolean
 ppc64_elf_tls_setup (struct bfd_link_info *info)
 {
   struct ppc_link_hash_table *htab;
@@ -7704,7 +7713,7 @@ ppc64_elf_tls_setup (struct bfd_link_info *info)
 
   htab = ppc_hash_table (info);
   if (htab == NULL)
-    return NULL;
+    return FALSE;
 
   if (abiversion (info->output_bfd) == 1)
     htab->opd_abi = 1;
@@ -7730,6 +7739,19 @@ ppc64_elf_tls_setup (struct bfd_link_info *info)
      --plt-localentry can cause trouble.  */
   if (htab->params->plt_localentry0 < 0)
     htab->params->plt_localentry0 = 0;
+  if (htab->params->plt_localentry0 && htab->has_power10_relocs)
+    {
+      /* The issue is that __glink_PLTresolve saves r2, which is done
+	 because glibc ld.so _dl_runtime_resolve restores r2 to support
+	 a glibc plt call optimisation where global entry code is
+	 skipped on calls that resolve to the same binary.  The
+	 __glink_PLTresolve save of r2 is incompatible with code
+	 making tail calls, because the tail call might go via the
+	 resolver and thus overwrite the proper saved r2.  */
+      _bfd_error_handler (_("warning: --plt-localentry is incompatible with "
+			    "power10 pc-relative code"));
+      htab->params->plt_localentry0 = 0;
+    }
   if (htab->params->plt_localentry0
       && elf_link_hash_lookup (&htab->elf, "GLIBC_2.26",
 			       FALSE, FALSE, FALSE) == NULL)
@@ -7826,7 +7848,7 @@ ppc64_elf_tls_setup (struct bfd_link_info *info)
 		      _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
 					      opt_fd->dynstr_index);
 		      if (!bfd_elf_link_record_dynamic_symbol (info, opt_fd))
-			return NULL;
+			return FALSE;
 		    }
 		  if (tga_fd != NULL)
 		    {
@@ -7885,7 +7907,7 @@ ppc64_elf_tls_setup (struct bfd_link_info *info)
       && htab->params->no_tls_get_addr_regsave == -1)
     htab->params->no_tls_get_addr_regsave = 0;
 
-  return _bfd_elf_tls_setup (info->output_bfd, info);
+  return TRUE;
 }
 
 /* Return TRUE iff REL is a branch reloc with a global symbol matching
@@ -10834,62 +10856,60 @@ eh_advance_size (unsigned int delta)
 static inline unsigned int
 plt_stub_size (struct ppc_link_hash_table *htab,
 	       struct ppc_stub_hash_entry *stub_entry,
-	       bfd_vma off)
+	       bfd_vma off,
+	       unsigned int odd)
 {
   unsigned size;
 
   if (stub_entry->stub_type >= ppc_stub_plt_call_notoc)
     {
       if (htab->params->power10_stubs != 0)
-	{
-	  bfd_vma start = (stub_entry->stub_offset
-			   + stub_entry->group->stub_sec->output_offset
-			   + stub_entry->group->stub_sec->output_section->vma);
-	  if (stub_entry->stub_type > ppc_stub_plt_call_notoc)
-	    start += 4;
-	  size = 8 + size_power10_offset (off, start & 4);
-	}
+	size = 8 + size_power10_offset (off, odd);
       else
 	size = 8 + size_offset (off - 8);
       if (stub_entry->stub_type > ppc_stub_plt_call_notoc)
 	size += 4;
-      return size;
     }
-
-  size = 12;
-  if (ALWAYS_EMIT_R2SAVE
-      || stub_entry->stub_type == ppc_stub_plt_call_r2save)
-    size += 4;
-  if (PPC_HA (off) != 0)
-    size += 4;
-  if (htab->opd_abi)
+  else
     {
-      size += 4;
-      if (htab->params->plt_static_chain)
+      size = 12;
+      if (ALWAYS_EMIT_R2SAVE
+	  || stub_entry->stub_type == ppc_stub_plt_call_r2save)
 	size += 4;
-      if (htab->params->plt_thread_safe
-	  && htab->elf.dynamic_sections_created
-	  && stub_entry->h != NULL
-	  && stub_entry->h->elf.dynindx != -1)
-	size += 8;
-      if (PPC_HA (off + 8 + 8 * htab->params->plt_static_chain) != PPC_HA (off))
+      if (PPC_HA (off) != 0)
 	size += 4;
+      if (htab->opd_abi)
+	{
+	  size += 4;
+	  if (htab->params->plt_static_chain)
+	    size += 4;
+	  if (htab->params->plt_thread_safe
+	      && htab->elf.dynamic_sections_created
+	      && stub_entry->h != NULL
+	      && stub_entry->h->elf.dynindx != -1)
+	    size += 8;
+	  if (PPC_HA (off + 8 + 8 * htab->params->plt_static_chain)
+	      != PPC_HA (off))
+	    size += 4;
+	}
     }
   if (stub_entry->h != NULL
       && is_tls_get_addr (&stub_entry->h->elf, htab)
       && htab->params->tls_get_addr_opt)
     {
-      if (htab->params->no_tls_get_addr_regsave)
+      if (!htab->params->no_tls_get_addr_regsave)
 	{
-	  size += 7 * 4;
-	  if (stub_entry->stub_type == ppc_stub_plt_call_r2save)
-	    size += 6 * 4;
+	  size += 30 * 4;
+	  if (stub_entry->stub_type == ppc_stub_plt_call_r2save
+	      || stub_entry->stub_type == ppc_stub_plt_call_both)
+	    size += 4;
 	}
       else
 	{
-	  size += 30 * 4;
-	  if (stub_entry->stub_type == ppc_stub_plt_call_r2save)
-	    size += 4;
+	  size += 7 * 4;
+	  if (stub_entry->stub_type == ppc_stub_plt_call_r2save
+	      || stub_entry->stub_type == ppc_stub_plt_call_both)
+	    size += 6 * 4;
 	}
     }
   return size;
@@ -10904,7 +10924,8 @@ plt_stub_size (struct ppc_link_hash_table *htab,
 static inline unsigned int
 plt_stub_pad (struct ppc_link_hash_table *htab,
 	      struct ppc_stub_hash_entry *stub_entry,
-	      bfd_vma plt_off)
+	      bfd_vma plt_off,
+	      unsigned int odd)
 {
   int stub_align;
   unsigned stub_size;
@@ -10919,7 +10940,7 @@ plt_stub_pad (struct ppc_link_hash_table *htab,
     }
 
   stub_align = 1 << -htab->params->plt_stub_align;
-  stub_size = plt_stub_size (htab, stub_entry, plt_off);
+  stub_size = plt_stub_size (htab, stub_entry, plt_off, odd);
   if (((stub_off + stub_size - 1) & -stub_align) - (stub_off & -stub_align)
       > ((stub_size - 1) & -stub_align))
     return stub_align - (stub_off & (stub_align - 1));
@@ -11114,14 +11135,12 @@ build_plt_stub (struct ppc_link_hash_table *htab,
 #define MR_R3_R0	0x7c030378
 #define BCTRL		0x4e800421
 
-static inline bfd_byte *
-build_tls_get_addr_stub (struct ppc_link_hash_table *htab,
+static bfd_byte *
+build_tls_get_addr_head (struct ppc_link_hash_table *htab,
 			 struct ppc_stub_hash_entry *stub_entry,
-			 bfd_byte *p, bfd_vma offset, Elf_Internal_Rela *r)
+			 bfd_byte *p)
 {
   bfd *obfd = htab->params->stub_bfd;
-  bfd_byte *loc = p;
-  unsigned int i;
 
   bfd_put_32 (obfd, LD_R0_0R3 + 0, p),		p += 4;
   bfd_put_32 (obfd, LD_R12_0R3 + 8, p),		p += 4;
@@ -11130,21 +11149,43 @@ build_tls_get_addr_stub (struct ppc_link_hash_table *htab,
   bfd_put_32 (obfd, ADD_R3_R12_R13, p),		p += 4;
   bfd_put_32 (obfd, BEQLR, p),			p += 4;
   bfd_put_32 (obfd, MR_R3_R0, p),		p += 4;
-  if (htab->params->no_tls_get_addr_regsave)
-    {
-      if (r != NULL)
-	r[0].r_offset += 7 * 4;
-      if (stub_entry->stub_type != ppc_stub_plt_call_r2save)
-	return build_plt_stub (htab, stub_entry, p, offset, r);
 
+  if (!htab->params->no_tls_get_addr_regsave)
+    p = tls_get_addr_prologue (obfd, p, htab);
+  else if (stub_entry->stub_type == ppc_stub_plt_call_r2save
+	   || stub_entry->stub_type == ppc_stub_plt_call_both)
+    {
       bfd_put_32 (obfd, MFLR_R0, p);
       p += 4;
       bfd_put_32 (obfd, STD_R0_0R1 + STK_LINKER (htab), p);
       p += 4;
+    }
+  return p;
+}
 
-      if (r != NULL)
-	r[0].r_offset += 2 * 4;
-      p = build_plt_stub (htab, stub_entry, p, offset, r);
+static bfd_byte *
+build_tls_get_addr_tail (struct ppc_link_hash_table *htab,
+			 struct ppc_stub_hash_entry *stub_entry,
+			 bfd_byte *p,
+			 bfd_byte *loc)
+{
+  bfd *obfd = htab->params->stub_bfd;
+
+  if (!htab->params->no_tls_get_addr_regsave)
+    {
+      bfd_put_32 (obfd, BCTRL, p - 4);
+
+      if (stub_entry->stub_type == ppc_stub_plt_call_r2save
+	  || stub_entry->stub_type == ppc_stub_plt_call_both)
+	{
+	  bfd_put_32 (obfd, LD_R2_0R1 + STK_TOC (htab), p);
+	  p += 4;
+	}
+      p = tls_get_addr_epilogue (obfd, p, htab);
+    }
+  else if (stub_entry->stub_type == ppc_stub_plt_call_r2save
+	   || stub_entry->stub_type == ppc_stub_plt_call_both)
+    {
       bfd_put_32 (obfd, BCTRL, p - 4);
 
       bfd_put_32 (obfd, LD_R2_0R1 + STK_TOC (htab), p);
@@ -11156,24 +11197,6 @@ build_tls_get_addr_stub (struct ppc_link_hash_table *htab,
       bfd_put_32 (obfd, BLR, p);
       p += 4;
     }
-  else
-    {
-      p = tls_get_addr_prologue (obfd, p, htab);
-
-      if (r != NULL)
-	r[0].r_offset += 18 * 4;
-
-      p = build_plt_stub (htab, stub_entry, p, offset, r);
-      bfd_put_32 (obfd, BCTRL, p - 4);
-
-      if (stub_entry->stub_type == ppc_stub_plt_call_r2save)
-	{
-	  bfd_put_32 (obfd, LD_R2_0R1 + STK_TOC (htab), p);
-	  p += 4;
-	}
-
-      p = tls_get_addr_epilogue (obfd, p, htab);
-    }
 
   if (htab->glink_eh_frame != NULL
       && htab->glink_eh_frame->size != 0)
@@ -11182,21 +11205,11 @@ build_tls_get_addr_stub (struct ppc_link_hash_table *htab,
 
       base = htab->glink_eh_frame->contents + stub_entry->group->eh_base + 17;
       eh = base + stub_entry->group->eh_size;
-      if (htab->params->no_tls_get_addr_regsave)
-	{
-	  unsigned int lr_used, delta;
-	  lr_used = stub_entry->stub_offset + (p - 20 - loc);
-	  delta = lr_used - stub_entry->group->lr_restore;
-	  stub_entry->group->lr_restore = lr_used + 16;
-	  eh = eh_advance (htab->elf.dynobj, eh, delta);
-	  *eh++ = DW_CFA_offset_extended_sf;
-	  *eh++ = 65;
-	  *eh++ = -(STK_LINKER (htab) / 8) & 0x7f;
-	  *eh++ = DW_CFA_advance_loc + 4;
-	}
-      else
+
+      if (!htab->params->no_tls_get_addr_regsave)
 	{
-	  unsigned int cfa_updt, delta;
+	  unsigned int cfa_updt, delta, i;
+
 	  /* After the bctrl, lr has been modified so we need to emit
 	     .eh_frame info saying the return address is on the stack.  In
 	     fact we must put the EH info at or before the call rather
@@ -11235,10 +11248,27 @@ build_tls_get_addr_stub (struct ppc_link_hash_table *htab,
 	  for (i = 4; i < 12; i++)
 	    *eh++ = DW_CFA_restore + i;
 	  *eh++ = DW_CFA_advance_loc + 2;
+	  *eh++ = DW_CFA_restore_extended;
+	  *eh++ = 65;
+	  stub_entry->group->eh_size = eh - base;
+	}
+      else if (stub_entry->stub_type == ppc_stub_plt_call_r2save
+	       || stub_entry->stub_type == ppc_stub_plt_call_both)
+	{
+	  unsigned int lr_used, delta;
+
+	  lr_used = stub_entry->stub_offset + (p - 20 - loc);
+	  delta = lr_used - stub_entry->group->lr_restore;
+	  stub_entry->group->lr_restore = lr_used + 16;
+	  eh = eh_advance (htab->elf.dynobj, eh, delta);
+	  *eh++ = DW_CFA_offset_extended_sf;
+	  *eh++ = 65;
+	  *eh++ = -(STK_LINKER (htab) / 8) & 0x7f;
+	  *eh++ = DW_CFA_advance_loc + 4;
+	  *eh++ = DW_CFA_restore_extended;
+	  *eh++ = 65;
+	  stub_entry->group->eh_size = eh - base;
 	}
-      *eh++ = DW_CFA_restore_extended;
-      *eh++ = 65;
-      stub_entry->group->eh_size = eh - base;
     }
   return p;
 }
@@ -11372,6 +11402,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
   struct ppc_branch_hash_entry *br_entry;
   struct bfd_link_info *info;
   struct ppc_link_hash_table *htab;
+  bfd *obfd;
   bfd_byte *loc;
   bfd_byte *p, *relp;
   bfd_vma targ, off;
@@ -11379,6 +11410,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
   asection *plt;
   int num_rel;
   int odd;
+  bfd_boolean is_tga;
 
   /* Massage our args to the form they really have.  */
   stub_entry = (struct ppc_stub_hash_entry *) gen_entry;
@@ -11428,6 +11460,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
       off = targ - off;
 
       p = loc;
+      obfd = htab->params->stub_bfd;
       if (stub_entry->stub_type == ppc_stub_long_branch_r2off)
 	{
 	  bfd_vma r2off = get_r2off (info, stub_entry);
@@ -11437,23 +11470,21 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	      htab->stub_error = TRUE;
 	      return FALSE;
 	    }
-	  bfd_put_32 (htab->params->stub_bfd, STD_R2_0R1 + STK_TOC (htab), p);
+	  bfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p);
 	  p += 4;
 	  if (PPC_HA (r2off) != 0)
 	    {
-	      bfd_put_32 (htab->params->stub_bfd,
-			  ADDIS_R2_R2 | PPC_HA (r2off), p);
+	      bfd_put_32 (obfd, ADDIS_R2_R2 | PPC_HA (r2off), p);
 	      p += 4;
 	    }
 	  if (PPC_LO (r2off) != 0)
 	    {
-	      bfd_put_32 (htab->params->stub_bfd,
-			  ADDI_R2_R2 | PPC_LO (r2off), p);
+	      bfd_put_32 (obfd, ADDI_R2_R2 | PPC_LO (r2off), p);
 	      p += 4;
 	    }
 	  off -= p - loc;
 	}
-      bfd_put_32 (htab->params->stub_bfd, B_DOT | (off & 0x3fffffc), p);
+      bfd_put_32 (obfd, B_DOT | (off & 0x3fffffc), p);
       p += 4;
 
       if (off + (1 << 25) >= (bfd_vma) (1 << 26))
@@ -11579,19 +11610,17 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	}
 
       p = loc;
+      obfd = htab->params->stub_bfd;
       if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)
 	{
 	  if (PPC_HA (off) != 0)
 	    {
-	      bfd_put_32 (htab->params->stub_bfd,
-			  ADDIS_R12_R2 | PPC_HA (off), p);
+	      bfd_put_32 (obfd, ADDIS_R12_R2 | PPC_HA (off), p);
 	      p += 4;
-	      bfd_put_32 (htab->params->stub_bfd,
-			  LD_R12_0R12 | PPC_LO (off), p);
+	      bfd_put_32 (obfd, LD_R12_0R12 | PPC_LO (off), p);
 	    }
 	  else
-	    bfd_put_32 (htab->params->stub_bfd,
-			LD_R12_0R2 | PPC_LO (off), p);
+	    bfd_put_32 (obfd, LD_R12_0R2 | PPC_LO (off), p);
 	}
       else
 	{
@@ -11603,36 +11632,32 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	      return FALSE;
 	    }
 
-	  bfd_put_32 (htab->params->stub_bfd, STD_R2_0R1 + STK_TOC (htab), p);
+	  bfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p);
 	  p += 4;
 	  if (PPC_HA (off) != 0)
 	    {
-	      bfd_put_32 (htab->params->stub_bfd,
-			  ADDIS_R12_R2 | PPC_HA (off), p);
+	      bfd_put_32 (obfd, ADDIS_R12_R2 | PPC_HA (off), p);
 	      p += 4;
-	      bfd_put_32 (htab->params->stub_bfd,
-			  LD_R12_0R12 | PPC_LO (off), p);
+	      bfd_put_32 (obfd, LD_R12_0R12 | PPC_LO (off), p);
 	    }
 	  else
-	    bfd_put_32 (htab->params->stub_bfd, LD_R12_0R2 | PPC_LO (off), p);
+	    bfd_put_32 (obfd, LD_R12_0R2 | PPC_LO (off), p);
 
 	  if (PPC_HA (r2off) != 0)
 	    {
 	      p += 4;
-	      bfd_put_32 (htab->params->stub_bfd,
-			  ADDIS_R2_R2 | PPC_HA (r2off), p);
+	      bfd_put_32 (obfd, ADDIS_R2_R2 | PPC_HA (r2off), p);
 	    }
 	  if (PPC_LO (r2off) != 0)
 	    {
 	      p += 4;
-	      bfd_put_32 (htab->params->stub_bfd,
-			  ADDI_R2_R2 | PPC_LO (r2off), p);
+	      bfd_put_32 (obfd, ADDI_R2_R2 | PPC_LO (r2off), p);
 	    }
 	}
       p += 4;
-      bfd_put_32 (htab->params->stub_bfd, MTCTR_R12, p);
+      bfd_put_32 (obfd, MTCTR_R12, p);
       p += 4;
-      bfd_put_32 (htab->params->stub_bfd, BCTR, p);
+      bfd_put_32 (obfd, BCTR, p);
       p += 4;
       break;
 
@@ -11646,12 +11671,23 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
       off = (stub_entry->stub_offset
 	     + stub_entry->group->stub_sec->output_offset
 	     + stub_entry->group->stub_sec->output_section->vma);
+      obfd = htab->params->stub_bfd;
+      is_tga = ((stub_entry->stub_type == ppc_stub_plt_call_notoc
+		 || stub_entry->stub_type == ppc_stub_plt_call_both)
+		&& stub_entry->h != NULL
+		&& is_tls_get_addr (&stub_entry->h->elf, htab)
+		&& htab->params->tls_get_addr_opt);
+      if (is_tga)
+	{
+	  p = build_tls_get_addr_head (htab, stub_entry, p);
+	  off += p - loc;
+	}
       if (stub_entry->stub_type == ppc_stub_long_branch_both
 	  || stub_entry->stub_type == ppc_stub_plt_branch_both
 	  || stub_entry->stub_type == ppc_stub_plt_call_both)
 	{
 	  off += 4;
-	  bfd_put_32 (htab->params->stub_bfd, STD_R2_0R1 + STK_TOC (htab), p);
+	  bfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p);
 	  p += 4;
 	}
       if (stub_entry->stub_type >= ppc_stub_plt_call_notoc)
@@ -11684,17 +11720,39 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
       if (htab->params->power10_stubs != 0)
 	{
 	  bfd_boolean load = stub_entry->stub_type >= ppc_stub_plt_call_notoc;
-	  p = build_power10_offset (htab->params->stub_bfd, p, off, odd, load);
+	  p = build_power10_offset (obfd, p, off, odd, load);
 	}
       else
 	{
+	  if (htab->glink_eh_frame != NULL
+	      && htab->glink_eh_frame->size != 0)
+	    {
+	      bfd_byte *base, *eh;
+	      unsigned int lr_used, delta;
+
+	      base = (htab->glink_eh_frame->contents
+		      + stub_entry->group->eh_base + 17);
+	      eh = base + stub_entry->group->eh_size;
+	      lr_used = stub_entry->stub_offset + (p - loc) + 8;
+	      delta = lr_used - stub_entry->group->lr_restore;
+	      stub_entry->group->lr_restore = lr_used + 8;
+	      eh = eh_advance (htab->elf.dynobj, eh, delta);
+	      *eh++ = DW_CFA_register;
+	      *eh++ = 65;
+	      *eh++ = 12;
+	      *eh++ = DW_CFA_advance_loc + 2;
+	      *eh++ = DW_CFA_restore_extended;
+	      *eh++ = 65;
+	      stub_entry->group->eh_size = eh - base;
+	    }
+
 	  /* The notoc stubs calculate their target (either a PLT entry or
 	     the global entry point of a function) relative to the PC
 	     returned by the "bcl" two instructions past the start of the
 	     sequence emitted by build_offset.  The offset is therefore 8
 	     less than calculated from the start of the sequence.  */
 	  off -= 8;
-	  p = build_offset (htab->params->stub_bfd, p, off,
+	  p = build_offset (obfd, p, off,
 			    stub_entry->stub_type >= ppc_stub_plt_call_notoc);
 	}
 
@@ -11706,17 +11764,19 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 		  + stub_entry->group->stub_sec->output_offset
 		  + stub_entry->group->stub_sec->output_section->vma
 		  + (p - loc));
-	  bfd_put_32 (htab->params->stub_bfd,
-		      B_DOT | ((targ - from) & 0x3fffffc), p);
+	  bfd_put_32 (obfd, B_DOT | ((targ - from) & 0x3fffffc), p);
 	}
       else
 	{
-	  bfd_put_32 (htab->params->stub_bfd, MTCTR_R12, p);
+	  bfd_put_32 (obfd, MTCTR_R12, p);
 	  p += 4;
-	  bfd_put_32 (htab->params->stub_bfd, BCTR, p);
+	  bfd_put_32 (obfd, BCTR, p);
 	}
       p += 4;
 
+      if (is_tga)
+	p = build_tls_get_addr_tail (htab, stub_entry, p, loc);
+
       if (info->emitrelocations)
 	{
 	  bfd_vma roff = relp - stub_entry->group->stub_sec->contents;
@@ -11747,33 +11807,6 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 		return FALSE;
 	    }
 	}
-
-      if (htab->params->power10_stubs == 0
-	  && htab->glink_eh_frame != NULL
-	  && htab->glink_eh_frame->size != 0)
-	{
-	  bfd_byte *base, *eh;
-	  unsigned int lr_used, delta;
-
-	  base = (htab->glink_eh_frame->contents
-		  + stub_entry->group->eh_base + 17);
-	  eh = base + stub_entry->group->eh_size;
-	  lr_used = stub_entry->stub_offset + 8;
-	  if (stub_entry->stub_type == ppc_stub_long_branch_both
-	      || stub_entry->stub_type == ppc_stub_plt_branch_both
-	      || stub_entry->stub_type == ppc_stub_plt_call_both)
-	    lr_used += 4;
-	  delta = lr_used - stub_entry->group->lr_restore;
-	  stub_entry->group->lr_restore = lr_used + 8;
-	  eh = eh_advance (htab->elf.dynobj, eh, delta);
-	  *eh++ = DW_CFA_register;
-	  *eh++ = 65;
-	  *eh++ = 12;
-	  *eh++ = DW_CFA_advance_loc + 2;
-	  *eh++ = DW_CFA_restore_extended;
-	  *eh++ = 65;
-	  stub_entry->group->eh_size = eh - base;
-	}
       break;
 
     case ppc_stub_plt_call:
@@ -11842,12 +11875,20 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	    r[0].r_offset += 2;
 	  r[0].r_addend = targ;
 	}
-      if (stub_entry->h != NULL
-	  && is_tls_get_addr (&stub_entry->h->elf, htab)
-	  && htab->params->tls_get_addr_opt)
-	p = build_tls_get_addr_stub (htab, stub_entry, loc, off, r);
-      else
-	p = build_plt_stub (htab, stub_entry, loc, off, r);
+      p = loc;
+      obfd = htab->params->stub_bfd;
+      is_tga = (stub_entry->h != NULL
+		&& is_tls_get_addr (&stub_entry->h->elf, htab)
+		&& htab->params->tls_get_addr_opt);
+      if (is_tga)
+	{
+	  p = build_tls_get_addr_head (htab, stub_entry, p);
+	  if (r != NULL)
+	    r[0].r_offset += p - loc;
+	}
+      p = build_plt_stub (htab, stub_entry, p, off, r);
+      if (is_tga)
+	p = build_tls_get_addr_tail (htab, stub_entry, p, loc);
       break;
 
     case ppc_stub_save_res:
@@ -12143,11 +12184,19 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 
     case ppc_stub_plt_call_notoc:
     case ppc_stub_plt_call_both:
-      off = (stub_entry->stub_offset
-	     + stub_entry->group->stub_sec->output_offset
-	     + stub_entry->group->stub_sec->output_section->vma);
+      lr_used = 0;
+      if (stub_entry->h != NULL
+	  && is_tls_get_addr (&stub_entry->h->elf, htab)
+	  && htab->params->tls_get_addr_opt)
+	{
+	  lr_used += 7 * 4;
+	  if (!htab->params->no_tls_get_addr_regsave)
+	    lr_used += 11 * 4;
+	  else if (stub_entry->stub_type == ppc_stub_plt_call_both)
+	    lr_used += 2 * 4;
+	}
       if (stub_entry->stub_type == ppc_stub_plt_call_both)
-	off += 4;
+	lr_used += 4;
       targ = stub_entry->plt_ent->plt.offset & ~1;
       if (targ >= (bfd_vma) -2)
 	abort ();
@@ -12163,16 +12212,21 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	    plt = htab->pltlocal;
 	}
       targ += plt->output_offset + plt->output_section->vma;
+      off = (stub_entry->stub_offset
+	     + stub_entry->group->stub_sec->output_offset
+	     + stub_entry->group->stub_sec->output_section->vma
+	     + lr_used);
       odd = off & 4;
       off = targ - off;
 
       if (htab->params->plt_stub_align != 0)
 	{
-	  unsigned pad = plt_stub_pad (htab, stub_entry, off);
+	  unsigned pad = plt_stub_pad (htab, stub_entry, off, odd);
 
 	  stub_entry->group->stub_sec->size += pad;
 	  stub_entry->stub_offset = stub_entry->group->stub_sec->size;
 	  off -= pad;
+	  odd ^= pad & 4;
 	}
 
       if (info->emitrelocations)
@@ -12186,15 +12240,13 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	  stub_entry->group->stub_sec->flags |= SEC_RELOC;
 	}
 
-      size = plt_stub_size (htab, stub_entry, off);
+      size = plt_stub_size (htab, stub_entry, off, odd);
 
       if (htab->params->power10_stubs == 0)
 	{
 	  /* After the bcl, lr has been modified so we need to emit
 	     .eh_frame info saying the return address is in r12.  */
-	  lr_used = stub_entry->stub_offset + 8;
-	  if (stub_entry->stub_type == ppc_stub_plt_call_both)
-	    lr_used += 4;
+	  lr_used += stub_entry->stub_offset + 8;
 	  /* The eh_frame info will consist of a DW_CFA_advance_loc or
 	     variant, DW_CFA_register, 65, 12, DW_CFA_advance_loc+2,
 	     DW_CFA_restore_extended 65.  */
@@ -12202,6 +12254,30 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	  stub_entry->group->eh_size += eh_advance_size (delta) + 6;
 	  stub_entry->group->lr_restore = lr_used + 8;
 	}
+      if ((stub_entry->stub_type == ppc_stub_plt_call_notoc
+	   || stub_entry->stub_type == ppc_stub_plt_call_both)
+	  && stub_entry->h != NULL
+	  && is_tls_get_addr (&stub_entry->h->elf, htab)
+	  && htab->params->tls_get_addr_opt)
+	{
+	  if (!htab->params->no_tls_get_addr_regsave)
+	    {
+	      unsigned int cfa_updt = stub_entry->stub_offset + 18 * 4;
+	      delta = cfa_updt - stub_entry->group->lr_restore;
+	      stub_entry->group->eh_size += eh_advance_size (delta);
+	      stub_entry->group->eh_size += htab->opd_abi ? 36 : 35;
+	      stub_entry->group->lr_restore
+		= stub_entry->stub_offset + size - 4;
+	    }
+	  else if (stub_entry->stub_type == ppc_stub_plt_call_both)
+	    {
+	      lr_used = stub_entry->stub_offset + size - 20;
+	      delta = lr_used - stub_entry->group->lr_restore;
+	      stub_entry->group->eh_size += eh_advance_size (delta) + 6;
+	      stub_entry->group->lr_restore
+		= stub_entry->stub_offset + size - 4;
+	    }
+	}
       break;
 
     case ppc_stub_plt_call:
@@ -12227,7 +12303,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 
       if (htab->params->plt_stub_align != 0)
 	{
-	  unsigned pad = plt_stub_pad (htab, stub_entry, off);
+	  unsigned pad = plt_stub_pad (htab, stub_entry, off, 0);
 
 	  stub_entry->group->stub_sec->size += pad;
 	  stub_entry->stub_offset = stub_entry->group->stub_sec->size;
@@ -12244,14 +12320,22 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	  stub_entry->group->stub_sec->flags |= SEC_RELOC;
 	}
 
-      size = plt_stub_size (htab, stub_entry, off);
+      size = plt_stub_size (htab, stub_entry, off, 0);
 
       if (stub_entry->h != NULL
 	  && is_tls_get_addr (&stub_entry->h->elf, htab)
 	  && htab->params->tls_get_addr_opt
 	  && stub_entry->stub_type == ppc_stub_plt_call_r2save)
 	{
-	  if (htab->params->no_tls_get_addr_regsave)
+	  if (!htab->params->no_tls_get_addr_regsave)
+	    {
+	      /* Adjustments to r1 need to be described.  */
+	      unsigned int cfa_updt = stub_entry->stub_offset + 18 * 4;
+	      delta = cfa_updt - stub_entry->group->lr_restore;
+	      stub_entry->group->eh_size += eh_advance_size (delta);
+	      stub_entry->group->eh_size += htab->opd_abi ? 36 : 35;
+	    }
+	  else
 	    {
 	      lr_used = stub_entry->stub_offset + size - 20;
 	      /* The eh_frame info will consist of a DW_CFA_advance_loc
@@ -12260,15 +12344,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	      delta = lr_used - stub_entry->group->lr_restore;
 	      stub_entry->group->eh_size += eh_advance_size (delta) + 6;
 	    }
-	  else
-	    {
-	      /* Adjustments to r1 need to be described.  */
-	      unsigned int cfa_updt = stub_entry->stub_offset + 18 * 4;
-	      delta = cfa_updt - stub_entry->group->lr_restore;
-	      stub_entry->group->eh_size += eh_advance_size (delta);
-	      stub_entry->group->eh_size += htab->opd_abi ? 36 : 35;
-	    }
-	  stub_entry->group->lr_restore = size - 4;
+	  stub_entry->group->lr_restore = stub_entry->stub_offset + size - 4;
 	}
       break;
 
@@ -13814,11 +13890,11 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)
 	  /* Augmentation.  */
 	  p += 1;
 
-	  *p++ = DW_CFA_advance_loc + 1;
+	  *p++ = DW_CFA_advance_loc + (htab->has_plt_localentry0 ? 3 : 2);
 	  *p++ = DW_CFA_register;
 	  *p++ = 65;
 	  *p++ = htab->opd_abi ? 12 : 0;
-	  *p++ = DW_CFA_advance_loc + (htab->opd_abi ? 5 : 7);
+	  *p++ = DW_CFA_advance_loc + (htab->opd_abi ? 4 : 2);
 	  *p++ = DW_CFA_restore_extended;
 	  *p++ = 65;
 	  p += ((24 + align - 1) & -align) - 24;
@@ -14179,8 +14255,6 @@ write_plt_relocs_for_local_syms (struct bfd_link_info *info)
 		}
 
 	      val = sym->st_value + ent->addend;
-	      if (ELF_ST_TYPE (sym->st_info) != STT_GNU_IFUNC)
-		val += PPC64_LOCAL_ENTRY_OFFSET (sym->st_other);
 	      if (sym_sec != NULL && sym_sec->output_section != NULL)
 		val += sym_sec->output_offset + sym_sec->output_section->vma;
 
@@ -14414,23 +14488,60 @@ ppc64_elf_build_stubs (struct bfd_link_info *info,
 	}
       else
 	{
+	  unsigned int insn;
+
+	  /* 0:
+	     .	.quad plt0-1f		# plt0 entry relative to 1:
+	     #
+	     # We get here with r12 initially @ a glink branch
+	     # Load the address of _dl_runtime_resolve from plt0 and
+	     # jump to it, with r0 set to the index of the PLT entry
+	     # to be resolved and r11 the link map.
+	     __glink_PLTresolve:
+	     .	std %r2,24(%r1)		# optional
+	     .	mflr %r0
+	     .	bcl 20,31,1f
+	     1:
+	     .	mflr %r11
+	     .	mtlr %r0
+	     .	ld %r0,(0b-1b)(%r11)
+	     .	sub %r12,%r12,%r11
+	     .	add %r11,%r0,%r11
+	     .	addi %r0,%r12,1b-2f
+	     .	ld %r12,0(%r11)
+	     .	srdi %r0,%r0,2
+	     .	mtctr %r12
+	     .	ld %r11,8(%r11)
+	     .	bctr
+	     2:
+	     .	b __glink_PLTresolve
+	     .	...
+	     .	b __glink_PLTresolve  */
+
+	  if (htab->has_plt_localentry0)
+	    {
+	      bfd_put_32 (htab->glink->owner, STD_R2_0R1 + 24, p);
+	      p += 4;
+	    }
 	  bfd_put_32 (htab->glink->owner, MFLR_R0, p);
 	  p += 4;
 	  bfd_put_32 (htab->glink->owner, BCL_20_31, p);
 	  p += 4;
 	  bfd_put_32 (htab->glink->owner, MFLR_R11, p);
 	  p += 4;
-	  bfd_put_32 (htab->glink->owner, STD_R2_0R1 + 24, p);
-	  p += 4;
-	  bfd_put_32 (htab->glink->owner, LD_R2_0R11 | (-16 & 0xfffc), p);
-	  p += 4;
 	  bfd_put_32 (htab->glink->owner, MTLR_R0, p);
 	  p += 4;
+	  if (htab->has_plt_localentry0)
+	    insn = LD_R0_0R11 | (-20 & 0xfffc);
+	  else
+	    insn = LD_R0_0R11 | (-16 & 0xfffc);
+	  bfd_put_32 (htab->glink->owner, insn, p);
+	  p += 4;
 	  bfd_put_32 (htab->glink->owner, SUB_R12_R12_R11, p);
 	  p += 4;
-	  bfd_put_32 (htab->glink->owner, ADD_R11_R2_R11, p);
+	  bfd_put_32 (htab->glink->owner, ADD_R11_R0_R11, p);
 	  p += 4;
-	  bfd_put_32 (htab->glink->owner, ADDI_R0_R12 | (-48 & 0xffff), p);
+	  bfd_put_32 (htab->glink->owner, ADDI_R0_R12 | (-44 & 0xffff), p);
 	  p += 4;
 	  bfd_put_32 (htab->glink->owner, LD_R12_0R11, p);
 	  p += 4;
@@ -15880,22 +15991,25 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	      addend = 0;
 	      reloc_dest = DEST_STUB;
 
-	      if (((stub_entry->stub_type == ppc_stub_plt_call
-		    && ALWAYS_EMIT_R2SAVE)
-		   || stub_entry->stub_type == ppc_stub_plt_call_r2save
-		   || stub_entry->stub_type == ppc_stub_plt_call_both)
-		  && !(h != NULL
-		       && is_tls_get_addr (&h->elf, htab)
-		       && htab->params->tls_get_addr_opt)
-		  && rel + 1 < relend
-		  && rel[1].r_offset == rel->r_offset + 4
-		  && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOCSAVE)
-		relocation += 4;
-	      else if ((stub_entry->stub_type == ppc_stub_long_branch_both
-			|| stub_entry->stub_type == ppc_stub_plt_branch_both
-			|| stub_entry->stub_type == ppc_stub_plt_call_both)
-		       && r_type == R_PPC64_REL24_NOTOC)
-		relocation += 4;
+	      if ((((stub_entry->stub_type == ppc_stub_plt_call
+		     && ALWAYS_EMIT_R2SAVE)
+		    || stub_entry->stub_type == ppc_stub_plt_call_r2save
+		    || stub_entry->stub_type == ppc_stub_plt_call_both)
+		   && rel + 1 < relend
+		   && rel[1].r_offset == rel->r_offset + 4
+		   && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOCSAVE)
+		  || ((stub_entry->stub_type == ppc_stub_long_branch_both
+		       || stub_entry->stub_type == ppc_stub_plt_branch_both
+		       || stub_entry->stub_type == ppc_stub_plt_call_both)
+		      && r_type == R_PPC64_REL24_NOTOC))
+		{
+		  /* Skip over the r2 store at the start of the stub.  */
+		  if (!(stub_entry->stub_type >= ppc_stub_plt_call
+			&& htab->params->tls_get_addr_opt
+			&& h != NULL
+			&& is_tls_get_addr (&h->elf, htab)))
+		    relocation += 4;
+		}
 
 	      if (r_type == R_PPC64_REL24_NOTOC
 		  && (stub_entry->stub_type == ppc_stub_plt_call_notoc
@@ -15944,7 +16058,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	  break;
 
 	case R_PPC64_GOT16_DS:
-	  if ((h ? h->elf.type : ELF_ST_TYPE (sym->st_info)) == STT_GNU_IFUNC)
+	  if ((h ? h->elf.type : ELF_ST_TYPE (sym->st_info)) == STT_GNU_IFUNC
+	      || !htab->do_toc_opt)
 	    break;
 	  from = TOCstart + htab->sec_info[input_section->id].toc_off;
 	  if (relocation + addend - from + 0x8000 < 0x10000
@@ -15963,7 +16078,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 
 	case R_PPC64_GOT16_LO_DS:
 	case R_PPC64_GOT16_HA:
-	  if ((h ? h->elf.type : ELF_ST_TYPE (sym->st_info)) == STT_GNU_IFUNC)
+	  if ((h ? h->elf.type : ELF_ST_TYPE (sym->st_info)) == STT_GNU_IFUNC
+	      || !htab->do_toc_opt)
 	    break;
 	  from = TOCstart + htab->sec_info[input_section->id].toc_off;
 	  if (relocation + addend - from + 0x80008000ULL < 0x100000000ULL
@@ -15986,34 +16102,38 @@ ppc64_elf_relocate_section (bfd *output_bfd,
 	  break;
 
 	case R_PPC64_GOT_PCREL34:
-	  if ((h ? h->elf.type : ELF_ST_TYPE (sym->st_info)) == STT_GNU_IFUNC)
+	  if ((h ? h->elf.type : ELF_ST_TYPE (sym->st_info)) == STT_GNU_IFUNC
+	      || !htab->do_toc_opt)
 	    break;
 	  from = (rel->r_offset
 		  + input_section->output_section->vma
 		  + input_section->output_offset);
-	  if (relocation - from + (1ULL << 33) < 1ULL << 34
-	      && SYMBOL_REFERENCES_LOCAL (info, &h->elf))
-	    {
-	      offset = rel->r_offset;
-	      pinsn = bfd_get_32 (input_bfd, contents + offset);
-	      pinsn <<= 32;
-	      pinsn |= bfd_get_32 (input_bfd, contents + offset + 4);
-	      if ((pinsn & ((-1ULL << 50) | (63ULL << 26)))
-		   == ((1ULL << 58) | (1ULL << 52) | (57ULL << 26) /* pld */))
-		{
-		  /* Replace with paddi.  */
-		  pinsn += (2ULL << 56) + (14ULL << 26) - (57ULL << 26);
-		  r_type = R_PPC64_PCREL34;
-		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
-		  bfd_put_32 (input_bfd, pinsn >> 32, contents + offset);
-		  bfd_put_32 (input_bfd, pinsn, contents + offset + 4);
-		  goto pcrelopt;
-		}
-	    }
-	  break;
+	  if (!(relocation - from + (1ULL << 33) < 1ULL << 34
+		&& SYMBOL_REFERENCES_LOCAL (info, &h->elf)))
+	    break;
+
+	  offset = rel->r_offset;
+	  pinsn = bfd_get_32 (input_bfd, contents + offset);
+	  pinsn <<= 32;
+	  pinsn |= bfd_get_32 (input_bfd, contents + offset + 4);
+	  if ((pinsn & ((-1ULL << 50) | (63ULL << 26)))
+	      != ((1ULL << 58) | (1ULL << 52) | (57ULL << 26) /* pld */))
+	    break;
+
+	  /* Replace with paddi.  */
+	  pinsn += (2ULL << 56) + (14ULL << 26) - (57ULL << 26);
+	  r_type = R_PPC64_PCREL34;
+	  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
+	  bfd_put_32 (input_bfd, pinsn >> 32, contents + offset);
+	  bfd_put_32 (input_bfd, pinsn, contents + offset + 4);
+	  /* Fall through.  */
 
 	case R_PPC64_PCREL34:
-	  if (SYMBOL_REFERENCES_LOCAL (info, &h->elf))
+	  if (!htab->params->no_pcrel_opt
+	      && rel + 1 < relend
+	      && rel[1].r_offset == rel->r_offset
+	      && rel[1].r_info == ELF64_R_INFO (0, R_PPC64_PCREL_